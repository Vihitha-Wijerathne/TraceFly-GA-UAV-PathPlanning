# -*- coding: utf-8 -*-
"""lidar_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Krguy0qtLWHCQwdaPKsHciA_T-e7F90E

## Install required dependencies
"""

!pip install open3d numpy matplotlib tensorflow

"""## Import required libraries"""

import os
import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import open3d as o3d
import matplotlib.pyplot as plt
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import tensorflow as tf

"""# 1. Mount Google Drive & Load Data"""

from google.colab import drive
drive.mount('/content/drive')

# Define paths to store data
data_path = "/content/drive/MyDrive/"
model_save_path = os.path.join(data_path, "trained_lidar_model.pth")
training_data_path = os.path.join(data_path, "training_point_cloud.ply")
training_labels_path = os.path.join(data_path, "training_labels.txt")

# Load pre-trained models
pointpillars_model_path = os.path.join(data_path, "PointPillars_Object_Detection.h5")
centerpoint_model_path = os.path.join(data_path, "CenterPoint_Detection.h5")

"""# 2. Load Point Cloud & Labels"""

def load_point_cloud(file_path):
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")
    point_cloud = o3d.io.read_point_cloud(file_path)
    if len(point_cloud.points) == 0:
        raise ValueError(f"Point cloud file is empty or invalid: {file_path}")
    return np.asarray(point_cloud.points)

def load_labels(file_path):
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"Label file not found: {file_path}")
    with open(file_path, 'r') as f:
        labels = np.array([int(line.strip()) for line in f if not line.startswith("#")])
    return labels

# Load training dataset
train_points = load_point_cloud(training_data_path)
train_labels = load_labels(training_labels_path)

"""# 3. Preprocess Data"""

num_classes = len(set(train_labels.tolist()))
train_labels -= min(train_labels)

# Convert to PyTorch tensors
train_points_tensor = torch.tensor(train_points, dtype=torch.float32)
train_labels_tensor = torch.tensor(train_labels, dtype=torch.long)

"""# 4. Load Pre-Trained PointPillars & CenterPoint Models"""

pointpillars_model = tf.keras.models.load_model(pointpillars_model_path)
centerpoint_model = tf.keras.models.load_model(centerpoint_model_path)

"""# 5. Define Neural Network with Temporal Fusion"""

class FeatureExtractor(nn.Module):
    """Extracts features from raw LiDAR point clouds."""
    def __init__(self, input_dim=3, output_dim=512):
        super(FeatureExtractor, self).__init__()
        self.fc1 = nn.Linear(input_dim, 1024)
        self.fc2 = nn.Linear(1024, output_dim)
        self.relu = nn.ReLU()

    def forward(self, x):
        x = self.relu(self.fc1(x))
        x = self.relu(self.fc2(x))
        return x

class TemporalFusion(nn.Module):
    """Uses LSTM to handle sequential dependencies for moving obstacles."""
    def __init__(self, input_dim, hidden_dim, num_layers=1):
        super(TemporalFusion, self).__init__()
        self.lstm = nn.LSTM(input_dim, hidden_dim, num_layers, batch_first=True)
        self.fc = nn.Linear(hidden_dim, input_dim)

    def forward(self, x):
        out, _ = self.lstm(x.unsqueeze(1))
        out = self.fc(out[:, -1, :])  # Use last output for prediction
        return out

class HybridModel(nn.Module):
    """Combines PointPillars & CenterPoint features with Temporal Fusion."""
    def __init__(self, num_classes):
        super(HybridModel, self).__init__()
        self.pointpillars_extractor = FeatureExtractor()
        self.centerpoint_extractor = FeatureExtractor()
        self.fusion_layer = nn.Linear(512 + 512, 256)
        self.temporal_fusion = TemporalFusion(input_dim=256, hidden_dim=128)
        self.classifier = nn.Linear(256, num_classes)

    def forward(self, x):
        pillars_features = self.pointpillars_extractor(x)
        center_features = self.centerpoint_extractor(x)
        combined_features = torch.cat((pillars_features, center_features), dim=1)
        combined_features = self.fusion_layer(combined_features)
        temporal_features = self.temporal_fusion(combined_features)
        output = self.classifier(temporal_features)
        return output

"""# 6. Train the Model"""

model = HybridModel(num_classes=num_classes)
optimizer = optim.Adam(model.parameters(), lr=0.0008)
criterion = nn.CrossEntropyLoss()

loss_history = []

def train_model(model, inputs, labels, epochs=30):
    model.train()
    global loss_history
    loss_history.clear()

    for epoch in range(epochs):
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        loss_history.append(loss.item())
        print(f"Epoch {epoch+1}, Loss: {loss.item():.4f}")

# Train the model
train_model(model, train_points_tensor, train_labels_tensor, epochs=25)

"""# 7. Save Trained Model to Google Drive"""

torch.save(model.state_dict(), model_save_path)
print(f" Trained model saved at: {model_save_path}")

"""# 8. Evaluate Model on Training Data"""

model.eval()
with torch.no_grad():
    predictions = model(train_points_tensor).argmax(dim=1).numpy()

accuracy = accuracy_score(train_labels, predictions)
precision = precision_score(train_labels, predictions, average="weighted", zero_division=0)
recall = recall_score(train_labels, predictions, average="weighted", zero_division=0)
f1 = f1_score(train_labels, predictions, average="weighted", zero_division=0)

print("\n **Model Performance Metrics on Training Data**")
print(f" Accuracy: {accuracy:.4f}")
print(f" Precision: {precision:.4f}")
print(f" Recall: {recall:.4f}")
print(f" F1 Score: {f1:.4f}")

"""# 9. Visualize Training Loss"""

plt.figure(figsize=(8, 5))
plt.plot(range(1, len(loss_history) + 1), loss_history, marker='o', linestyle='-', color='b')
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.title("Training Loss Over Epochs")
plt.grid()
plt.show()

# Download Model (Optional)
# from google.colab import files
# files.download(model_save_path)